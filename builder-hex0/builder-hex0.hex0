# Builder-Hex0 is a small bootable machine image which has
# the ability to compile hex0 code. It is also written in hex0
# and so it can build itself if provided with its own source code.
#
# hex0 is a "language" for binary encoding in hexadecimal
# with support for comments.

# --- stage 1
# _start
# console_putc_16
# console_put_hex_16
#
# get_drive_geometry
# next_sector
# read_sectors_16
# write_sectors_16
#
# [GDT data]
# mbr_main
# setup_interrupt_handlers
# [Partition Table]
# stub_interrupt_handler
# enter_16bit_real
# resume_32bit_mode
#
# console_putc
# console_put_hex
# console_puts
# get_partition_start
# read_sectors
# write_sectors
#
# syscall_interrupt_handler
# handle_syscall_open
# absolute_path
# find_file
# handle_syscall_read
# handle_syscall_brk
# handle_syscall_write
# handle_syscall_fork
# handle_syscall_execve
# handle_syscall_chdir
# handle_syscall_exit
# handle_syscall_lseek
#
# strcmp
#
# read
# write
# read_line
# write_line
# src
# hex0
# internalshell


#------------------------------------------------------------
# Memory:
#4000000 -        processes
# 500000 -3FFFFFF files
# 401800 - 4FFC00 file names 6..1023
# 401400 - 4017FF file name 5
# 401000 - 4013FF file name 4
# 400010 - 400FF0 file lengths 4*1022
# 300000 - 3FFFFF io buffers/free
# 200800 - 2FFFFF cmd arg3..1024 (1022 args * 1K)
# 200400 - 2007FF cmd arg2 (1K)
# 200000 - 2003FF cmd arg1 (1K)
# 100000 - 1FFFF0 32 bit stack (1M)
#  9FC00 -  FFFFF BIOS
#  40000 -  9FBFF device buffers
#  20000 -  3FFFF process descriptors
#  10800 -  1FFFF opened file descriptors (16 bytes each)
#  10000 -  10800 interrupt table
#   A000 -   A1FF sector read buffer - 16bit
#   7C00 -   8600 code
#   7B00 -   7BFF Saved 32 bit registers while in 16 bit mode
# < 7B00          real mode stack
#------------------------------------------------------------


# ------------------------------------------------------------
# Stub Entry Point
#
# boot drive is in dl
#
#[7C00][13]
#:_start

# We cannot be sure the registers are initialized to zero so we
# do that first. We far jump to mbr_main in order to set CS.
31 C0           # xor ax, ax
8E D8           # mov ds, ax
8E C0           # mov es, ax
8E D0           # mov ss, ax
BC 00 7B        # mov sp, 0x7B00
FC              # cld ; clear direction flag

EA 26 7D 00 00  # jmp mbr_main


# ------------------------
#[7C11][16]
#:console_putc_16(al=c)
#
# Note: with QEMU+Seabios this does not flush the last character or
# CRLF of a line until the first character is output on the next line
# and that character cannot be another CRLF.
53              # push bx
50              # push ax

# Prepare to use BIOS tty output interrupt.
# Specify text page 00, 0 black background, 7 light grey text
BB 00 07        # mov bx, 0x0007
# Specify the `write character` BIOS routine
B4 0E           # mov ah, 0x0E

3C 0A           # cmp al, 0x0A
75 06           # jne regular

# convert LF to CR LF for BIOS output
B0 0D           # mov al, 0x0D
CD 10           # int 0x10
B0 0A           # mov al, 0x0A

#:regular:
CD 10           # int 0x10

58              # pop ax
5B              # pop bx
CB              # retf


# ------------------------
#[7C27][31]
#:console_put_hex_16(al=byte)
50              # push ax

24 F0           # and al, 0xF0
C0 E8 04        # shr al, 4
3C 09           # cmp al, 9
7F 04           # jg alpha

#numeral:
04 30           # add al, 0x30
EB 02           # jmp print1

#alpha:
04 37           # add al, 0x37

#print1:
9A 11 7C 00 00  # call console_putc_16

58              # pop ax        ; restore original al
50              # push ax       ;

24 0F           # and al, 0x0F
3C 09           # cmp al, 9
7F 04           # jg alpha

#numeral:
04 30           # add al, 0x30
EB 02           # jmp print2

#alpha:
04 37           # add al, 0x37

#print2:
9A 11 7C 00 00  # call console_putc_16

58              # pop ax
CB              # retf



# ------------------------------------------------------------
# disk_geometry
#[7C51]
80     # boot_drive
0F     # boot drive max_head  0..15
3F     # boot drive max_sector / track (1..63)


#[7C54][18]
# ------------------------
#:get_drive_geometry(dl)
#
06              # push es
57              # push di

# https://en.wikipedia.org/wiki/INT_13H#INT_13h_AH=08h:_Read_Drive_Parameters
31 FF           # xor di, di
8E C7           # mov es, di
B4 08           # mov ah, 8       ; get drive parameters
CD 13           # int 0x13

88 36 52 7C     # mov [max_head], dh  ; max_head
80 E1 3F        # and cl, 0x3f
88 0E 53 7C     # mov [max_sector], cl  ; num_sectors

5F              # pop di
07              # pop es
CB              # retf


#[7C6C][37]
# ------------------------
#:next_sector(cx=cylinder/sector, dh = head)
#
50              # PUSH_AX

88 C8           # mov al, cl          ; get sector number
24 3F           # and al, 0x3f
3A 06 53 7C     # cmp al, [max_sector]; if sector_num == max_sector
74 04           # jz next_head        ;      goto next_head
FE C1           # inc cl              ; else sector_num++;
EB 28           # jmp cleanup

#next_head:
3A 36 52 7C     # cmp dh, [max_head]  ; if head_num == max_head
74 09           # jz next_cylinder    ;      goto next_cyclinder
FE C6           # inc dh              ; else head_num++
80 E1 C0        # and cl, 0xc0        ;      sector_num = 1
FE C1           # inc cl              ;
EB 19           # jmp cleanup

#next_cylinder:
80 FD FF        # cmp ch, 0xff        ; if cylinder_low == 255
74 0B           # je next_cyl_high

#next_cyl_low:
30 F6           # xor dh, dh          ; head_num = 0
80 E1 C0        # and cl, 0xc0        ; sector_num = 0
81 C1 01 01     # add cx, 0x0101      ; cylinder_low++, sector_num++
EB 09           # jmp cleanup

#next_cyl_high:
30 F6           # xor dh, dh          ; head_num = 0
81 C1 C0 00     # and cx, 0x00C0      ; cylinder_low = 0, sector_num = 0
80 C1 41        # add cl, 0x41        ; cylinder_high++, sector_num++

#cleanup:
58              # pop ax
CB              # retf


# ------------------------
#[7CA5][29]
#:read_sectors_16(di = *dest_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
#
# returns: di - next byte to write to
#          cx,dh - next disk sector to read from
#
50              # push ax
53              # push bx
56              # push si

89 C6           # mov si, ax      ; si=num_sectors
89 FB           # mov bx, di      ; int 13 writes to bx

#:read_one_loop
8A 16 51 7C     # mov dl, [boot_drive]
B4 02           # mov ah, 2        ; rw mode = 02 (read)
B0 01           # mov al, 1        ; num_sectors
CD 13           # int 0x13
72 F4           # jnc read_one_loop
3C 01           # cmp al, 1
75 F0           # jnz read_one_loop

# advance and maybe continue
9A 6C 7C 00 00  # call next_sector

# we read one sector, advance
81 C3 00 02     # add bx, 0x200

4E              # dec si            ; num_sectors--
75 E4           # jnz read_one_loop

89 DF           # mov di, bx

5E              # pop si
5B              # pop bx
58              # pop ax
CB              # retf


# ------------------------
#[7CCE][29]
#:write_sectors_16(si = *source_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
#
# returns: si - next byte to read from
#          cx,dh - next disk sector to read from
#
50              # push ax
53              # push bx
57              # push di

89 C7           # mov di, ax      ; di=num_sectors
89 F3           # mov bx, si      ; int 13 reads from [bx]

#:write_one_loop
8A 16 51 7C     # mov dl, [boot_drive]
B4 03           # mov ah, 3       ; rw mode = 03 (write)
B0 01           # mov al, 1       ; num_sectors
CD 13           # int 0x13
72 F4           # jnc write_one_loop
3C 01           # cmp al, 1
75 F0           # jnz write_one_loop

# advance and maybe continue
9A 6C 7C 00 00  # call next_sector

# we write one sector, advance
81 C3 00 02     # add bx, 0x200

4F              # dec di          ; num_sectors--
75 E4           # jnz write_one_loop

89 DE           # mov si, bx

5F              # pop di
5B              # pop bx
58              # pop ax
CB              # retf


#alignment only
00

#---------------------------------------------
# The Global Descriptor Table for 32 bit mode.
#---------------------------------------------
#[7CF8]
#:GDT_start:
00 00 00 00 00 00 00 00

#7D00 [+08]
#:GDT_code32:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
CF    # 11001111b
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    #

#7D08 [+10]
#:GDT_data32:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
CF    # flags, limit 16:19 11001111b
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    # base 24:31

#7D10 [+18]
#:GDT_code16:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
8F    # 10001111b
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    #

#7D18 [+20]
#:GDT_data16:
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
8F    # flags, limit 16:19 10001111b
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    # base 24:31

#7D20
#:GDT_locator
27 00        #  length
F8 7C 00 00  #  GDT_start


# ------------------------
#[7D26][1E]
#:mbr_main (dl=boot_drive)
# Load the kernel and jump to it
88 16 51 7C     # mov [boot_drive], dl
9A 54 7C 00 00  # call get_drive_geometry()
BF 00 7E        # mov di, 0x7E00   ; place remaining code after MBR in memory
B8 07 00        # mov ax, 0x0007   ; num_sectors = 7
B9 02 00        # mov cx, 0x0002   ; cylinder = 0, sector_num = 0x02
B6 00           # mov dh, 0        ; head = 0
9A A5 7C 00 00  # call read_sectors_16

#: start 32bit mode
B8 01 24              # mov ax,2401h     # enable A20 line
CD 15                 # int 15h

FA                    # cli
0F 01 16 20 7D        # lgdt GDT_locator
0F 20 C0              # mov eax, cr0
66 83 C8 01           # or eax, 0x01
0F 22 C0              # mov cr0, eax
EA 59 7D 08 00        # jmp setup_32bit     ; sets CS
#[7D59]
#:setup_32bit
66 B8 10 00           # mov ax, 0x0010      ; data descriptor
8E D8                 # mov ds, ax
8E D0                 # mov ss, ax
8E C0                 # mov es, ax
8E E0                 # mov fs, ax
8E E8                 # mov gs, ax
BD 0F FF 1F 00        # mov ebp, 0x1FFFF0
89 EC                 # mov esp, ebp

9A 7C 7D 00 00 08 00  # call setup_interrupt_handlers
EA D0 86 00 00 08 00  # jmp internalshell


#----------------------------------------
#[7D7C][40]
#:setup_interrupt_handlers
53                    # push ebx

# handle the timer interrupt 08
BB 40 00 01 00        # mov ebx, &interrupt_table[08]
66 C7 03 BC 7D        # mov word [ebx + 0], low_address stub_interrupt_handler
66 C7 43 06 00 00     # mov word [ebx + 6], high_address
66 C7 43 02 08 00     # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E           # mov byte [ebx + 5], flags = 8E

# handle int 80
BB 00 04 01 00        # mov ebx, &interrupt_table[80]
66 C7 03 24 7F        # mov word [ebx + 0], low_address syscall_interrupt_handler
66 C7 43 06 00 00     # mov word [ebx + 6], high_address
66 C7 43 02 08 00     # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E           # mov byte [ebx + 5], flags = 8E

# load the interrupt table
FA                    # cli
0F 01 1D 00 7E 00 00  # lidt [0x00007EB3] IDT_locator_32
FB                    # sti
5B                    # pop ebx
CB                    # retf


#----------------------------------------
#stub_interrupt_handler
#[7DBC]
CF                    # iret

# padding
00

# Partition entry 1
#[7DBE]
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 01 00
# type non-fs data
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 2
#[7DCE]
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 02 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 3
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 03 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

# Partition entry 4
# status inactive
00
# first head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 09 00
# type "non-fs data"
DA
# last head,sector[0..5]+cylinder[8..9],cylinder[0..7]
00 00 00
# LBA start
00 00 00 00
# Num sectors
00 00 00 00

#[7DFE]
# This is the DOS/MBR identifier at offset 510:
55 AA


#----------------------------------------
#[7E00][06]
#:IDT_locator_32
FF 07        #  length
00 00 01 00  #  IDT_start


#------------------------------------------------------------
# 32 -> 16 -> 32 bit switching functions
#------------------------------------------------------------
# When switching between real mode and
# protected, registers are stored here:
#
# 7B14  edx
# 7B10
# 7B0C
# 7B08  eax
# 7B04  esp
#
# 7B00  <- top of real mode stack


#----------------------------------------
#[7E06][61]
#:enter_16bit_real
FA                    # cli
A3 08 7B 00 00        # mov [0x7B08], eax  ; preserve so we can use these locally
89 15 14 7B 00 00     # mov [0x7B14], edx  ;
5A                    # pop edx            ; capture return address
89 25 04 7B 00 00     # mov [0x7B04], esp  ; capture stack

# The following far jump sets CS to a 16-bit protected mode selector
# and the segment registers are also set to 16-bit protected mode selectors.
# This is done prior to entering real mode.
EA 20 7E 00 00 18 00  # jmp 0x18:setup_16bit
#[7E20]
#:setup_16bit
B8 20 00              # mov eax, 0x0020
8E D0                 # mov ss, eax
8E D8                 # mov ds, eax
8E C0                 # mov es, eax
8E E8                 # mov gs, eax
8E E0                 # mov fs, eax
BC 00 7B              # mov sp, 0x7B00
0F 20 C0              # mov eax, cr0
66 83 E0 FE           # and eax, 0xfffffffe  ; clear protected mode
0F 22 C0              # mov cr0, eax
# The following far jump sets CS to a 16-bit real mode segment
# and the segment registers are also set to real mode segments.
EA 3F 7E 00 00        # jmp 0000:XXXX  real_mode
#[7E3F]
#:real_mode
B8 00 00              # mov ax, 0x0
8E D8                 # mov ds, ax
8E E0                 # mov fs, ax
8E E8                 # mov gs, ax
8E D0                 # mov ss, ax
8E C0                 # mov es, ax
BC 00 7B              # mov sp, 0x7B00
FA                    # cli
0F 01 1E 61 7E        # lidt IDT
FB                    # sti
# Using retf to set CS comes from here:
# https://stackoverflow.com/questions/26448480/bios-interrupts-in-protected-mode
# This page recommends a far jump followed by sti:
# https://www.sudleyplace.com/pmtorm.html
6A 00                 # push 0x0000 (2 bytes!)  CS to return to
52                    # push dx  IP to return to
A1 08 7B              # mov ax, [0x7B08]  ; restore from above
8B 16 14 7b           # mov dx, [0x7B14]
CB                    # retf

# IDT
#[7E61]
FF FF
00 00 00 00


#----------------------------------------
#[7E67][40]
#:resume_32bit_mode()
FA                    # cli
A3 08 7B              # mov [0x7B08], ax  ; preserve, they might be return values from 16 bit
89 16 14 7b           # mov [0x7B14], dx
5A                    # pop dx      ; carry the return IP in dx
58                    # pop ax      ; CS
0F 01 16 20 7D        # lgdt GDT_locator
0F 20 C0              # mov eax, cr0
66 83 C8 01           # or eax, 0x01         ; enable protected mode
0F 22 C0              # mov cr0, eax
EA 85 7E 08 00        # JMP restore_32bit
#[7E85]
#:restore_32bit
B8 10 00 00 00        # mov eax, 0x0010      ; data descriptor
8E D8                 # mov ds, eax
8E D0                 # mov ss, eax
8E C0                 # mov es, eax
8E E0                 # mov fs, eax
8E E8                 # mov gs, eax
8B 25 04 7B 00 00     # mov esp, [0x7B04]   ; restore, (saved in enter_16bit_mode)
9A 7C 7D 00 00 08 00  # call setup_interrupt_handlers
52                    # push edx            ; setup our return location
# These restore the 16 bit portion of these registers, which may be a
# return value from a 16 bit function, and they also restore any previous high
# bits that were stored by enter_16bit_mode so these registers need not be
# saved when going to 16 bit mode and back if you want them left alone.
A1 08 7B 00 00        # mov eax, [0x7B08]   ; restore, (saved at top of this function)
8B 15 14 7B 00 00     # mov edx, [0x7B14]
C3                    # ret


# ------------------------
#[7EAE][10]
#:console_putc:
#
E8 53 FF FF FF  # CALL enter_16bit_real, next=[7EB3]
9A 11 7C 00 00  # CALL console_putc_16(al)
9A 67 7E 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#:console_put_hex
#[7EBE][10]
E8 43 FF FF FF  # CALL enter_16bit_real, next=[7EC3]
9A 27 7C 00 00  # CALL console_put_hex_16(al)
9A 67 7E 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7ECE][1A]
#:console_puts (ds:si = string)
#:puts_loop
50                    # push eax
56                    # push esi
8A 06                 # mov al, [esi]
3C 00                 # cmp al, 0
74 0A                 # jz end_loop
9A AE 7E 00 00 08 00  # call console_putc
46                    # inc esi
EB F0                 # jmp puts_loop
#:end_loop
B0 0A                 # mov al, 0A
9A AE 7E 00 00 08 00  # call console_putc
5E                    # pop esi
58                    # pop eax
CB                    # RETF


#[7EEC][18]
# ------------------------
#:get_partition_start(eax=partition_num 1..4)
#returns:
# cx = cylinder/sector
# dh = head
#
50              # PUSH_EAX
56              # PUSH_ESI

6B C0 10        # imul eax, 0x10
89 C6           # mov esi, eax         ; esi = entry_offset
BB AE 7D 00 00  # mov ebx, 7DAE        ; ebx = &partition_table[-1]
8A 74 33 01     # mov dh, [ebx+esi+1]  ; dh = head = partition_table[al][0]
66 8B 4C 33 02  # mov cx, [ebx+esi+2]  ; cx = cyl/sector = partition_table[al][1]

5E              # POP_ESI
58              # POP_EAX
CB              # retf


# ------------------------
#[7F04][10]
#:read_sectors(di = *dest_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
E8 FD FE FF FF  # CALL enter_16bit_real, next=[7F09]
9A A5 7C 00 00  # CALL read_sectors_16
9A 67 7E 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7F14][10]
#:write_sectors(si = *source_addr, cx=cylinder/sector, dh = head, ax=num_sectors)
E8 ED FE FF FF  # CALL enter_16bit_real, next=[7F19]
9A CE 7C 00 00  # CALL write_sectors_16
9A 67 7E 00 00  # CALL resume_32bit_mode
CB              # RETF


# ------------------------
#[7F24][29]
#:syscall_interrupt_handler
3C 01                 # cmp al, 1
75 08                 # jne try next
9A 62 83 00 00 08 00  # call handle_syscall_exit
CF                    # iret

3C 02                 # cmp al, 2
75 08                 # jne try next
9A D2 81 00 00 08 00  # call handle_syscall_fork
CF                    # iret

3C 03                 # cmp al, 3
75 08                 # jne try next
9A C8 80 00 00 08 00  # call handle_syscall_read
CF                    # iret

3C 04                 # cmp al, 4
75 08                 # jne try next
9A 8E 81 00 00 08 00  # call handle_syscall_write
CF                    # iret

3C 05                 # cmp al, 5
75 08                 # jne try next
9A AF 7F 00 00 08 00  # call handle_syscall_open
CF                    # iret

# close
3C 06                 # cmp al, 6
75 03                 # jne try next
31 C0                 # xor eax, eax
CF                    # iret

# waitpid
3C 07                 # cmp eax, 7
75 05                 # jne try next
31 C0                 # xor eax, eax
89 01                 # mov [ecx], eax
CF                    # iret

3C 0B                 # cmp eax, B
75 08                 # jne try next
9A FF 81 00 00 08 00  # call handle_syscall_execve
CF                    # iret

3C 0C                 # cmp eax, C
75 08                 # jne try next
9A 31 83 00 00 08 00  # call handle_syscall_chdir
CF                    # iret

3C 0F                 # cmp eax, F
75 03                 # jne try next
31 C0                 # xor eax, eax  ; chmod ok
CF                    # iret

3C 13                 # cmp eax, 0x13
75 08                 # jne try next
9A B7 83 00 00 08 00  # call handle_syscall_lseek
CF                    # iret

3C 2D                 # cmp eax, 2D
75 07                 # jne ret
9A 61 81 00 00 08 00  # call handle_syscall_brk
CF                    # iret


#----------------------------------------
#[7FA7][04]
# next_filenum
04 00 00 00

#[7FAB][04]
# next_file_address
00 00 00 0A

#[7FAF][20]
#:handle_syscall_open(ebx=filename, ecx=flags)
53                    # push ebx
51                    # push ecx
56                    # push esi
57                    # push edi

9A 21 80 00 00 08 00  # call absolute_path

F7 C1 03 00 00 00     # test ecx, 3
74 42                 # jz open_read

# copy filename to new slot
89 DE                 # mov esi, ebx
BF 00 00 40 00        # mov edi, 0x0400000
A1 A7 7F 00 00        # mov eax, [&next_filenum]
C1 E0 0A              # shl eax, 0a
01 C7                 # add edi, eax
B9 00 04 00 00        # mov ecx, 0x0000400
F3 A4                 # rep movsb

# set address of file
BF 00 08 01 00        # mov edi, 0x0010800            ; pfile_descriptor = &file_descriptor[0]
A1 A7 7F 00 00        # mov eax, [&next_filenum]
C1 E0 04              # shl eax, 04
01 C7                 # add edi, eax                  ; pfile_descriptor += sizeof(file_descriptor) * next_filenum
8B 0D AB 7F 00 00     # mov ecx, [next_file_address]


89 4F 04              # mov [edi+4], ecx              ; pfile_descriptor->file_addr = ecx

31 C0                 # xor eax, eax
89 47 08              # mov [edi+8], eax              ; pfile_descriptor->length = 0

A1 A7 7F 00 00        # mov eax, [next_filenum]       ; return next_filenum
FF 05 A7 7F 00 00     # inc [next_filenum]
EB 18                 # jmp finish

#open_read
9A 98 80 00 00 08 00  # call find_file
89 C1                 # mov ecx, eax
# set read offset to start of file
BE 00 08 01 00        # mov esi, 0x0010800       ; pfile_descriptor = &file_descriptor[0]
C1 E1 04              # shl ecx, 04
01 CE                 # add esi, ecx             ; pfile_descriptor += sizeof(file_descriptor) * filenum
31 C9                 # xor ecx, ecx
89 4E 0C              # mov [esi+0xC], ecx       ; current offset = 0

# finish

5F                    # pop edi
5E                    # pop esi
59                    # pop ecx
5B                    # pop ebx
CB                    # ret


#----------------------------------------
#[8021]
#:ebx = absolute_path(ebx)
50                    # push eax
56                    # push esi
57                    # push edi

# get cwd
8B 35 FB 81 00 00     # mov esi, [&next_process_num]
4E                    # dec esi = current process
C1 E6 09              # shl esi, 09
81 C6 00 01 02 00     # add esi, 0x0020100       ; pproc_descriptor = &pproc_descriptor[current_process_num].current_dir
BF 00 00 30 00        # mov edi, 0x00300000      ; io buffer
57                    # push edi

#strcpy_cwd
AC                    # lodsb
84 C0                 # test al, al
74 03                 # jz strcpy_path
AA                    # stosb
EB F8                 # jmp strcpy_cwd
#strcpy_path
89 DE                 # mov esi, ebx
#strcpy_path_loop
AC                    # lodsb
AA                    # stosb
84 C0                 # test al, al
75 FA                 # jnz strcpy_path_loop

# handle_dots: /. and /..
5E                    # pop esi                  ; get start location
56                    # push esi                 ; save start location
89 F2                 # mov edx, esi             ; save start of parent

## find_slash
AC                    # lodsb
3C 00                 # cmp al, 0
74 32                 # je strip_front
3C 2F                 # cmp al, '/'
75 F7                 # jne find_slash

#:found_slash
AC                    # lodsb
# check for /. or /..
3C 00                 # cmp al, 0
74 29                 # je strip_front
3C 2E                 # cmp al, '.'
74 04                 # je dot_or_dotdot
89 F2                 # mov edx, esi             ; record start of parent
EB EA                 # jmp find_slash
#dot_or_dotdot
AC                    # lodsb
3C 2E                 # cmp al, '.'
75 10                 # jne remove_dotslash

# remove_parent
89 D7                 # mov edi, edx
AC                    # lodsb
3C 00                 # cmp al, 0
75 01                 # jne copy
4E                    # dec esi                  ; go back to last
#copy
AC                    # lodsb
AA                    # stosb
3C 00                 # cmp al, 0
75 FA                 # jne copy
EB D1                 # jmp handle_dots

# remove_dotslash
89 F7                 # mov edi, esi
4F                    # dec edi
4F                    # dec edi
#copy
AC                    # lodsb
AA                    # stosb
3C 00                 # cmp al, 0
75 FA                 # jne copy
EB C5                 # jmp handle_dots

# strip_front
5B                    # pop ebx
66 8B 03              # mov ax, [ebx]
66 3D 2E 2F           # cmp ax, 0x2F2E
75 03                 # jne finish
83 C3 02              # add ebx, 2

#:finish
89 DE                 # mov esi, ebx

5F                    # pop edi
5E                    # pop esi
58                    # pop eax
CB


#----------------------------------------
#[8098]
#:find_file(char * ebx=file_name) returns eax=filenum
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

A1 A7 7F 00 00        # mov eax, [next_filenum]
48                    # dec eax
89 DE                 # mov esi, ebx

#:checkfile
89 C7                 # mov edi, eax
C1 E7 0A              # shl edi, 0x0a
81 C7 00 00 40 00     # add edi, 0x0400000
9A DD 83 00 00 08 00  # call strcmp
74 0B                 # je finish

48                    # dec eax
83 F8 03              # cmp eax, 3
75 E6                 # jne checkfile

B8 FF FF FF FF        # mov eax, 0xffffffff

#finish
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
CB                    # ret


#------------------------------------------------------------
#[80C8][70]
#:handle_syscall_read(ecx=*return_char, ebx=file, edx=length)
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

51                    # push ecx   ; we need this later to return char
83 FB 00              # cmp ebx, 0
75 5F                 # jne memfile

# stdin is /dev/hda4
# get current position
BB 00 08 01 00        # mov ebx, 0x10800
66 8B 0B              # mov cx, [ebx]
8A 73 02              # mov dh, [ebx+2]
31 C0                 # xor eax, eax
66 8B 43 04           # mov ax, [ebx+4]

#end of sector?
66 3D ff 01           # cmp ax, 0x01ff
74 04                 # je next sector

#nextchar:
66 40                 # inc ax
EB 2A                 # jmp getchar

#read next sector
BF 00 A0 00 00        # mov edi, 0x000A000
B8 01 00 00 00        # mov eax, 0x0001   ; num_sectors = 1
9A 04 7F 00 00 08 00  # call read_sectors
# save new location and offset
66 89 0b              # mov [ebx], cx
88 73 02              # mov [ebx+2], dh
31 C0                 # xor eax, eax

# move block to device buffer
BE 00 A0 00 00        # mov esi, 0x000A000
BF 00 00 04 00        # mov edi, 0x0040000
B9 00 02 00 00        # mov ecx, 0x0000200
F3 A4                 # rep movsb

#getchar:
66 A3 04 08 01 00     # mov [0x10804], ax
59                    # pop ecx
BB 00 00 04 00        # mov ebx, 0x40000    ; device buffer
89 C6                 # mov esi, eax        ; offset
8A 04 33              # mov al, [ebx+esi+0]
88 01                 # mov [ecx], al
B8 01 00 00 00        # mov eax, 1
EB 29                 # jmp finish

#memfile:

# get descriptor address
BE 00 08 01 00        # mov esi, 0x0010800     ; pfile_descriptor = &file_descriptor[0]
89 D9                 # mov ecx, ebx
C1 E1 04              # shl ecx, 04
01 CE                 # add esi, ecx           ; pfile_descriptor += sizeof(file_descriptor) * filenum


# prepare to read
31 C0                 # xor eax, eax            ; bytes_read = 0
5F                    # pop edi                 ; edi = p_dst
8B 5E 04              # mov ebx, [esi+4]        ; ebx = pfile_descriptor->file_address
89 D9                 # mov ecx, ebx            ;
03 4E 08              # add ecx, [esi+0x08]     ; ecx = file_address + length
49                    # dec ecx                 ; ecx = last address to read
03 5E 0C              # add ebx, [esi+0xC]      ; ebx = file_addr + current_offset
87 F3                 # xchg esi, ebx           ; esi = p_src

# read_loop
39 CE                 # cmp esi, ecx            ; past the end?
7F 08                 # jg finish

A4                    # movsb
40                    # inc eax                 ; bytes_read++
FF 43 0C              # inc long [ebx+0xC]      ; pfile_descriptor->current_offset++
4A                    # dec edx
75 F4                 # jnz read_loop

#finish:
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
CB                    # ret



#[8161]
#------------------------------------------------------------
#:handle_syscall_brk
56                    # push esi

A1 FB 81 00 00        # mov eax, [&next_process_num]
48                    # dec eax = current process

BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 09              # shl eax, 09
01 C6                 # add esi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum

85 DB                 # test ebx, ebx
74 13                 # jz get

# set
# initialize memory to zero
57                    # push edi
31 C0                 # xor eax, eax
8B 7E 04              # mov edi, [esi+4]
#init_loop
AA                    # stosb
39 DF                 # cmp edi, ebx
75 FB                 # jne init_loop
5F                    # pop edi

89 5E 04              # mov [esi+4], ebx
89 D8                 # mov eax, ebx
5E                    # pop esi
CB                    # ret

# get
8B 46 04              # mov eax, [esi+4]         ; pproc_descriptor->brk
5E                    # pop esi
CB                    # ret


#------------------------------------------------------------
#[818E]
#:handle_syscall_write(ebx=file,ecx=*char_to_write)
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

31 C0                 # xor eax, eax            ; bytes_written = 0

83 FB 02              # cmp ebx, 02             ; std file?
7F 12                 # jg memfile

# stdout,stderr -> console_out
#:std_loop
50                    # push eax                ; save num_written
8A 01                 # mov al, [ecx]
9A AE 7E 00 00 08 00  # call console_putc
58                    # pop eax                 ; restore num_written

40                    # inc eax                 ; num_written++
41                    # inc ecx                 ; p_dst++
4A                    # dec edx                 ; count--
75 F0                 # jnz std_loop
EB 22                 # jmp finish

#:memfile
C1 E3 04              # shl ebx, 04
81 C3 00 08 01 00     # add ebx, 0x010800       ; pfile_descriptor += sizeof(file_descriptor) * filenum
# prepare to write
89 CE                 # mov esi, ecx
8B 7B 04              # mov edi, [ebx+4]        ; ebx = pfile_descriptor->file_address
03 7B 0C              # add edi, [ebx+0xC]      ; ebx = file_addr + current_offset
#write_loop
A4                    # movsb
FF 43 0C              # inc long [ebx+0xC]   ; current_offset++
FF 43 08              # inc long [ebx+0x8]   ; file_length++
FF 05 AB 7F 00 00     # inc long [next_file_address]
40                    # inc eax              ; num_written++
4A                    # dec edx
75 EF                 # jnz write_loop

#finish
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
CB                    # ret


#----------------------------------------
#[81D2]
#:handle_syscall_fork
56                    # push esi
57                    # push edi

A1 FB 81 00 00        # mov eax, [&next_process_num]
48                    # dec eax = current process
BF 00 00 02 00        # mov edi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 09              # shl eax, 09
01 C7                 # add edi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum

89 E6                 # mov esi, esp
89 77 0c              # mov [edi+0xC], esi       ; save stack pointer so we can return again later
FF 47 10              # inc [edi+0x10]           ; fork = true

83 C7 20              # add edi, 0x20
B9 30 00 00 00        # mov ecx, 0x30
F3 A5                 # rep movsd                ; save stack

31 C0                 # xor eax, eax             ; return as child, we'll return again as parent when child exits
5F                    # pop edi
5E                    # pop esi
CB                    # ret


#----------------------------------------
#[81FB][04]
# next_process_num
01 00 00 00

#[81FF]
#:handle_syscall_execve (ebx = program_name, ecx = char **args, edx=env)
A1 FB 81 00 00        # mov eax, [next_process_num]
3C 01                 # cmp al, 1
75 0A                 # jne not_first_process

# first process
BD 00 02 02 00        # ebp = &proc_descriptor[1]
89 65 08              # mov [ebp+0x8], esp       ; save original stack pointer before pushing args
EB 23                 # jmp prepare_stack

# not_first_process
# check if current process forked or not.
# if so, create new process, if not overlay current
48                    # dec eax                  ; eax = current_process
C1 E0 09              # shl eax, 9
05 00 00 02 00        # add eax, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
8B 68 10              # mov ebp, [eax+0x10]      ; create_new_process = pproc->forked
85 ED                 # test ebp, ebp            ; did current process fork?
75 0B                 # jnz forked

#not_forked
8B 60 0C              # mov esp, [eax+0xC]       ; no fork so reset initial stack to same as current process
A1 FB 81 00 00        # mov eax, [next_process_num]
48                    # dec eax
EB 08                 # jump prepare_stack

#:forked
FF 48 10              # dec [eax+0x10]           ; fork handled so reset: fork = false
A1 FB 81 00 00        # mov eax, [next_process_num]


#prepare_stack
# eax=process number to use
# --- env ---
69 F8 00 00 E0 00     # imul edi, eax, 0xE00000
81 C7 00 00 E0 03     # add edi, 0x03E00000      ; edi = &env_memory[0]
6A 00                 # push 0                   ; push end of env
##:push_env_loop
## copy env arg to memory for this process
8B 32                 # mov esi, [edx]
85 F6                 # test esi, esi
74 0F                 # jz end_env_loop
57                    # push edi                 ; push p_arg
51                    # push ecx
B9 00 01 00 00        # mov ecx, 0x00000100      ; memory per arg
F3 A4                 # rep movsb                ; copy to new memory
59                    # pop ecx
83 C2 04              # add edx, 4
EB EB                 # jmp push_env_loop

# --- args ---
6A 00                 # push 0                   ; push end of args
69 f8 00 00 E0 00     # imul edi, eax, 0xE00000
81 C7 00 00 F0 03     # add edi, 0x03F00000      ; edi = &arg_memory[0]

# count args
31 C0                 # xor eax, eax             ; passed_args = 0
# countloop
83 39 00              # cmp long [ecx], 0
74 06                 # jz push_args
40                    # inc eax
83 C1 04              # add ecx, 4
EB F5                 # jmp countloop

# push_args
89 C2                 # mov edx, eax             ; save eax (can't push)
#:push_args_loop
83 E9 04              # sub ecx, 4

# copy arg to memory for this process
8B 31                 # mov esi, [ecx]

57                    # push edi                 ; push p_arg

51                    # push ecx
B9 00 01 00 00        # mov ecx, 0x00000100      ; memory per arg
F3 A4                 # rep movsb
59                    # pop ecx
48                    # dec eax
75 EE                 # jnz push_args_loop

# finish with argc
89 D0                 # mov eax, edx             ; restore eax
50                    # push eax = argc

# only save current process if there is one
A1 FB 81 00 00        # mov eax, [next_process_num]
83 F8 01              # cmp eax , 1
74 37                 # je setup_process_image

# get current process descriptor
48                    # dec eax
50                    # push eax                 ; save current process num
C1 E0 09              # shl eax, 09
05 00 00 02 00        # add eax, 0x0020000       ; pproc_descriptor = &proc_descriptor[current_process_num]

# copy cwd from current process
50                    # push eax
05 00 01 00 00        # add eax, 0x100
89 C6                 # mov esi, eax
05 00 02 00 00        # add eax, 0x200
89 C7                 # mov edi, eax
#loop
AC                    # lodsb
AA                    # stosb
3C 00                 # cmp al, 0
75 FA                 # jne loop
58                    # pop eax

# copy current process image to storage
8B 30                 # mov esi, [eax]           ; esi = pproc_descriptor->process_address
58                    # pop eax                  ; restore current process num
69 f8 00 00 E0 00     # imul edi, eax, 0xE00000
81 C7 00 00 30 01     # add edi, 0x1300000
B9 00 00 C0 00        # mov ecx, 0x00C00000      ; memory per process
F3 A4                 # rep movsb
40                    # inc eax                  ; eax = new process id

#:setup_process_image
50                    # push eax                 ; save new process id
# get file address and length
9A 21 80 00 00 08 00  # call absolute_path
9A 98 80 00 00 08 00  # call find_file           ; eax=find_file(ebx)
BA 00 08 01 00        # mov edx, 0x0010800       ; pfile_descriptor = &file_descriptor[0]
C1 E0 04              # shl eax, 04
01 C2                 # add edx, eax             ; pfile_descriptor += sizeof(file_descriptor) * filenum
8B 72 04              # mov esi, [edx+0x4]       ; esi = pfile_descriptor->file_address
8B 4A 08              # mov ecx, [edx+0x8]       ; ecx = pfile_descriptor->file_length
8B 7E 3C              # mov edi, [esi + 0x3C]    ; get declared process address

51                    # push ecx                 ; copy file image to process memory
57                    # push edi
F3 A4                 # rep movsb
5F                    # pop edi
59                    # pop ecx

58                    # pop eax                  ; restore new process num

85 ED                 # test ebp, ebp            ; new process (vs overlay)?
75 01                 # jnz record_process_address
48                    # dec eax                  ; overlay

# record process address
C1 E0 09              # shl eax, 09
05 00 00 02 00        # add eax, 0x0020000       ; pproc_descriptor = &pproc_descriptor[current_process_num]
89 38                 # mov [eax], edi           ; pproc_descriptor->process_address = edi

# setup brk
57                    # push edi
01 CF                 # add edi, ecx             ; set brk after code
81 C7 00 01 00 00     # add edi, 0x00010000      ; breathing room
89 78 04              # mov [eax+4], edi         ; pproc_descriptor->brk
31 FF                 # xor edi, edi
89 78 10              # mov [eax+0x10], edi        ; pproc->forked = false
5F                    # pop edi

85 ED                 # test ebp, ebp            ; new process (vs overlay)?
74 06                 # jz after_new_process

# prepare for next process
FF 05 FB 81 00 00     # inc [next_process_num]

#:after_new_process
# get entry point and jump
FF 77 18              # push [edi + 0x18]
31 C0                 # xor eax, eax
31 DB                 # xor ebx, ebx
31 C9                 # xor ecx, ecx
31 D2                 # xor edx, edx
31 F6                 # xor esi, esi
31 FF                 # xor edi, edi
31 ED                 # xor ebp, ebp
C3                    # ret


#----------------------------------------
#[8331]
#:handle_syscall_chdir
56                    # push esi
57                    # push edi

9A 21 80 00 00 08 00  # call absolute_path

89 DE                 # mov esi, ebx
8B 3D FB 81 00 00     # mov edi, [&next_process_num]
4F                    # dec edi = current process
C1 E7 09              # shl edi, 09
81 C7 00 01 02 00     # add edi, 0x0020100       ; pproc_descriptor = &pproc_descriptor[current_process_num].current_dir

# don't add trailing slash for current dir
AC                    # lodsb
3C 00                 # cmp al, 0
AA                    # stosb
74 0D                 # je finish

#loop
AC                    # lodsb
AA                    # stosb
3C 00                 # cmp al, 0
75 FA                 # jne loop
4F                    # dec edi

#:add_slash
B0 2F                 # mov al, '/'
AA                    # stosb
31 C0                 # xor eax, eax
AA                    # stosb

#:finish
5F                    # pop edi
5E                    # pop esi
CB                    # retf


#:handle_syscall_exit
#[8362]
89 D8                 # mov eax, ebx
85 C0                 # test eax, eax
74 02                 # jz okexit

FA                    # cli
F4                    # hlt

#:okexit
A1 FB 81 00 00        # mov eax, [&next_process_num]
48                    # dec eax = current process
A3 FB 81 00 00        # mov [&next_process_num], eax
48                    # dec eax = parent process

3C 00                 # cmp al, 0
75 0A                 # jne not_first
8B 25 08 02 02 00     # mov esp, [0x020208]
8b 04 24              # mov eax, [esp]
CB

#not_first
89 C3                 # mov ebx, eax
C1 E0 09              # shl eax, 09
05 00 00 02 00        # add eax, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]

8B 38                 # mov edi, [eax]           ; edi = pproc_descriptor->process_address
69 F3 00 00 E0 00     # imul esi, ebx, 0xE00000
81 C6 00 00 30 01     # add esi, 0x1300000
B9 00 00 C0 00        # mov ecx, 0x00C00000      ; memory per process
F3 A4                 # rep movsb

8B 60 0C              # mov esp, [eax+0xc]       ; restore stack pointer
89 C6                 # mov esi, eax
83 C6 20              # add esi, 0x20            ; restore top of stack
89 E7                 # mov edi, esp
B9 30 00 00 00        # mov ecx, 0x30
F3 A5                 # rep movsd

# mimic syscall_fork's finish                    ; go back to parent
5F                    # pop edi
5E                    # pop esi
CB                    # ret


#[83B7]
#handle_syscall_lseek
56                    # push esi

89 D8                 # mov eax, ebx
BE 00 08 01 00        # mov esi, 0x0010800       ; pfile_descriptor = &file_descriptor[0]
C1 E0 04              # shl eax, 04
01 C6                 # add esi, eax

83 FA 01              # cmp edx, 1
7F 07                 # jg seek_end

#:seek_set
89 4E 0C              # mov [esi+0xC], ecx       ; set current offset
89 C8                 # mov eax, ecx
EB 0B                 # jmp done

#:seek_end
8B 46 08              # mov eax, [esi+0x8]        ; get current_length
01 C8                 # add eax, ecx              ; current_length += offset
89 46 08              # mov [esi+0x8], eax        ; set current_length
89 46 0C              # mov [esi+0xc], eax        ; set current_pos

#done
5E                    # pop esi
CB                    # ret


# ------------------------------------------------------------
# Utilities
# ------------------------------------------------------------

#:strcmp(esi, edi) returns zf
#[83DD]
50                    # push eax
53                    # push ebx
56                    # push esi
57                    # push edi

#check_byte
8A 06                 # mov al, [esi]
8A 1F                 # mov bl, [edi]
38 D8                 # cmp al, bl
75 0A                 # jne finish
46                    # inc esi
47                    # inc edi
84 C0                 # test al, al
75 F2                 # jnz check_byte
84 DB                 # test bl, bl
75 EE                 # jnz check_byte

#finish
5F                    # pop edi
5E                    # pop esi
5B                    # pop ebx
58                    # pop eax
CB                    # ret


# ----------------------------------------
# variables for read
#
#[83F8]  char io_char
00
00  # free

#[83FA]
#:read
53                    # push ebx
51                    # push ecx
52                    # push edx
B8 03 00 00 00        # mov eax, 3   ; syscall=read
B9 F8 83 00 00        # mov ecx, &io_char
BA 01 00 00 00        # mov edx, 1

CD 80                 # int 80 syscall

3C 00                 # cmp al, 0
74 07                 # je finish

B4 01                 # mov ah, 1
A0 F8 83 00 00        # mov al, &io_char

#finish
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
CB                    # ret


#[841D][26]
#:write
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx

A2 F8 83 00 00        # mov &io_char, al
B8 04 00 00 00        # mov eax, 4   ; syscall=write
B9 F8 83 00 00        # mov ecx, &io_char
BA 01 00 00 00        # mov edx, 1   1 byte characters
CD 80                 # int 80 syscall

5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret


#[843C][0F]
#:read_line(ebx=file, edi=linemem)
50                    # push eax
9A FA 83 00 00 08 00  # call read
AA                    # stosb
3C 0A                 # cmp al, '\n'
75 F4                 # jne read_line
58                    # pop eax
CB                    # ret


#[844B][0F]
#:write_line(ebx=file, esi=linemem)
50                    # push eax
#write_char
AC                    # lodsb
9A 1D 84 00 00 08 00  # call write
3C 0A                 # cmp al, '\n'
75 F4                 # jne write_char

58                    # pop eax
CB                    # ret


#[845A][04]
#s  r  c \0
73 72 63 00

#----------------------------------------
# src: create file from stdin
#
# Read an integer, N, in decimal from stdin.
# Read a space.
# Then, read a file name to create.
# Read a newline.
# Then, read N lines from stdin and write to the new file.
#[845E]
#:src
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

BE 5A 84 00 00        # mov esi,  "src"
9A CE 7E 00 00 08 00  # call console_puts

9A FA 83 00 00 08 00  # call read 'r'
9A FA 83 00 00 08 00  # call read 'c'
9A FA 83 00 00 08 00  # call read ' '

31 C9                 # xor ecx, ecx        ; line count=0
#parse_line_count_loop:
9A FA 83 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 0C                 # je got count

6B C9 0A              # imul ecx, ecx, 10   ; count = count * 10
2C 30                 # sub al, 30
0F B6 C0              # movzx eax, al
01 C1                 # add ecx, eax        ; count += digit

EB E9                 # jmp parse_line_count_loop

# got_count:
# clear arguments
51                    # push ecx
31 C0                 # xor eax, eax
BA 00 00 20 00        # mov edx, 0x00200000
B9 00 08 00 00        # mov ecx, 0x00000800

#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop
59                    # pop ecx

51                    # push ecx
B9 00 00 20 00        # mov ecx, 0x00200000
# get_filename_loop:
9A FA 83 00 00 08 00  # call read

3C 0A                 # cmp al, '\n'
74 05                 # je got_filename
88 01                 # mov [ecx], al
41                    # inc ecx
EB F0                 # jmp get_file_name_loop
59                    # pop ecx

# got_filename:
BE 00 00 20 00        # mov esi, 0x00200000
9A CE 7E 00 00 08 00  # call console_puts

# open filename for write
51                    # push ecx
BB 00 00 20 00        # mov ebx, 0x00200000
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 41 02 00 00        # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00        # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                 # int 80
59                    # pop ecx

# eax has the open file number

# readwrite_loop:
BF 00 00 30 00        # mov edi, 0x00300000     ; io buffer
57                    # push edi                ; save buffer address
31 DB                 # xor ebx, ebx            ; ebx=0=stdin
9A 3C 84 00 00 08 00  # call read_line
89 C3                 # mov ebx, eax            ;  prepare to write
5E                    # pop esi                 ; restore buffer address to esi
9A 4B 84 00 00 08 00  # call write_line
49                    # dec ecx   ; count--
75 E4                 # jnz read_write_loop

5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB                    # ret



#------------------------------------------------------------
#[8510][05]
#h  e  x  0 \0
68 65 78 30 00

#:hex0
#[8515]
53                    # push ebx
56                    # push esi
57                    # push edi

BE 10 85 00 00        # mov esi,  "hex0"
9A CE 7E 00 00 08 00  # call console_puts

# read "ex0 '
B1 04                 # mov cl, 4
9A FA 83 00 00 08 00  # call read
FE C9                 # dec cl
75 F5                 # jnz loop

# clear arguments
31 C0                 # xor eax, eax
BA 00 00 20 00        # mov edx, 0x00200000
B9 00 08 00 00        # mov ecx, 0x00000800
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop

BA 00 00 20 00        # mov edx, 0x00200000
#get_file_name1_loop
9A FA 83 00 00 08 00  # call read
9A AE 7E 00 00 08 00  # call console_putc
3C 20                 # cmp al, ' '
74 05                 # je got_filename1
88 02                 # mov [edx], al
42                    # inc edx
EB E9                 # jmp get_file_name_loop

#got_filename1
BA 00 04 20 00        # mov edx, 0x00200400
#get_file_name2_loop
9A FA 83 00 00 08 00  # call read
9A AE 7E 00 00 08 00  # call console_putc
3C 0A                 # cmp al, '\n'
74 05                 # je got_filename2
88 02                 # mov [edx], al
42                    # inc edx
EB E9                 # jmp get_file_name2_loop

# open filename1 for read
BB 00 00 20 00        # mov ebx, 0x00200000
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 00 00 00 00        # mov ecx, 0x00000000
CD 80                 # int 80

50                    # push eax  ; save read filenum

# open filename2 for write
BB 00 04 20 00        # mov ebx, 0x00200400
B8 05 00 00 00        # mov eax, 5  ; syscall_open
B9 41 02 00 00        # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00        # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                 # int 80
89 C2                 # mov edx, eax

59                    # pop ecx                 ; restore read filenum

# this flag is set after the first digit is seen
31 DB                 # xor ebx, ebx


#[85A8]
#:read_loop
53                    # push ebx
89 CB                 # mov ebx, ecx
9A FA 83 00 00 08 00  # call read
5B                    # pop ebx
#f5

84 e4                 # test ah, ah
75 04                 # jnz check_command
5F                    # POP_DI
5E                    # POP_SI
5B                    # POP_BX
CB                    # RETF

#:check_command
3C 23                 # cmp al, '#'

#cf
74 28                 # jz skip_comment

3C 3B                 # cmp ';'
74 24                 # jz skip_comment

3C 66                 # cmp al, 'f'
7F D1                 # jg read_loop

3C 61                 # cmp al, 'a'
7C 04                 # jl maybe_upper

# Handle a to f
2C 57                 # sub al, 'a'-10 == 87 = 0x57
EB 29                 # jmp maybe_store

#:maybe_upper
3C 46                 # cmp al, 'F'
7F D5                 # jg read_loop

3C 41                 # cmp al, 'A'
7C 04                 # jl maybe_digit

# Handle A to F
2C 37                 # sub al, 'A'-10 == 55 = x37
EB 1D                 # jmp maybe_store

#:maybe_digit
3C 39                 # cmp al, '9'
7F C9                 # jg read_loop

3C 30                 # cmp al, '0'
7C C5                 # jl read_loop

# Handle 0 to 9
2C 30                 # sub al, '0' == x30
EB 11                 # jmp maybe_store

#:skip_comment
53                    # push ebx
89 CB                 # mov ebx, ecx
9A FA 83 00 00 08 00  # call read
5B                    # pop ebx
3C 0A                 # cmp al, '\n'
75 F1                 # jnz skip_comment
EB B0                 # jmp read_loop

# only store on second digit
#:maybe_store
84 DB                 # test bl, bl
75 09                 # jnz second_digit

# If on first digit, record and keep going
#:first_digit
C0 E0 04              # shl al, 4
88 C7                 # mov bh, al
FE C3                 # inc bl
EB A3                 # jmp read_loop

# If on second digit, store and clear state
#:second_digit
08 C7                 # or bh, al
88 F8                 # mov al, bh

53                    # push ebx
89 D3                 # mov ebx, edx
9A 1D 84 00 00 08 00  # call write
5B                    # pop ebx

31 DB                 # xor bx, bx
EA A8 85 00 00 08 00  # jmp read_loop


#[861D]
#[cmd_args]
00 00 20 00
00 04 20 00
#[8625]
#[cmd_env]
00 00 00 00

#------------------------------------------------------------
#:handle_other_command
#[8629]
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi

# clear arguments
BA 00 00 20 00        # mov edx, 0x00200000
88 02                 # mov [edx], al
42                    # inc edx
31 C0                 # xor eax, eax
B9 FF 07 00 00        # mov ecx, 0x000007FF
#zeroloop
88 02                 # mov [edx], al
42                    # inc edx
49                    # dec ecx
75 FA                 # jnz zeroloop

BA 01 00 20 00        # mov edx, 0x00200001
#get_program_name
9A FA 83 00 00 08 00  # call read
3C 20                 # cmp al, ' '
74 05                 # je got_program_name
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_program_name

#got_program_name
BA 00 04 20 00        # mov edx, 0x00200400
#get_file_name2_loop
9A FA 83 00 00 08 00  # call read
3C 0A                 # cmp al, '\n'
74 05                 # je got_filename2
88 02                 # mov [edx], al
42                    # inc edx
EB F0                 # jmp get_file_name_loop

BE 00 00 20 00        # mov esi, program
9A CE 7E 00 00 08 00  # call console_puts

BE 00 04 20 00        # mov esi, arg1
9A CE 7E 00 00 08 00  # call console_puts

BB 00 00 20 00        # mov ebx, program_name
B9 1D 86 00 00        # mov ecx, cmd_args
BA 25 86 00 00        # mov edx, cmd_env
9A FF 81 00 00 08 00  # call handle_syscall_execve

5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
CB


#[86A1][10]
#B  u  i  l  d     f  i  n  i  s  h  e  d  . \0
42 75 69 6C 64 20 66 69 6E 69 73 68 65 64 2E 00

#[86B1][16]
#E  R  R  O  R  :     n  o     h  d  a     w  r  i  t  e  s  ! \0
45 52 52 4F 52 3A 20 6E 6F 20 68 64 61 20 77 72 69 74 65 73 21 00

#[86C7]
#/  d  e  v  /  h  d  a \0
2F 64 65 76 2F 68 64 61 00

#[86D0]
# ------------------------------------------------------------
# Main Program Body
# ------------------------------------------------------------
#:internalshell
# Set up /dev/hda4 as global stdin
B8 04 00 00 00        # mov eax, 4
9A EC 7E 00 00 08 00  # call get_partition_start(4)

# save disk location and byte offset to descriptor
66 89 0D 00 08 01 00  # mov [0x10800], cx
88 35 02 08 01 00     # mov [0x10802], dh
# start at "end of sector" to trigger an initial sector read
66 B9 FF 01           # mov cx, 0x01FF
66 89 0D 04 08 01 00  # mov [0x10804], cx

# read from stdin
31 DB                 # xor ebx, ebx

#:process_command:
9A FA 83 00 00 08 00  # call read
3C 00                 # cmp al, 0
74 23                 # je finish

#check_src_command
3C 73                 # cmp al, 's'
75 09                 # jne check_hex0

#handle_src_command
9A 5E 84 00 00 08 00  # call src
EB E8                 # jmp process_command

#check_hex0_command
3C 68                 # cmp al, 'h'
75 09                 # jne handle_other_command

#handle_hex0_command
9A 15 85 00 00 08 00  # call hex0
EB DB                 # jmp process_command

#handle_other_command:
9A 29 86 00 00 08 00  # call handle_other_command
EB D2                 # jmp process_command

#finish
BE A1 86 00 00        # mov esi, "Build finished."
9A CE 7E 00 00 08 00  # call console_puts

# copy memory file /dev/hda to the boot disk
BB C7 86 00 00        # mov ebx, "/dev/hda"
9A 98 80 00 00 08 00  # call find_file
83 f8 ff              # cmp eax, -1
75 17                 # jne ok_exit

#:error_exit
BE B1 86 00 00        # mov esi, "ERROR: No hda writes!"
9A CE 7E 00 00 08 00  # call console_puts

# one space to flush last line
B0 20                 # mov al, 20
9A AE 7E 00 00 08 00  # call console_putc
EB 6E                 # jmp reboot

# ok_exit
# get file address to read
C1 E0 04              # shl eax, 04
05 00 08 01 00        # add eax, 0x0010800
8B 70 04              # mov esi, [eax+4]         ; file_address
8B 58 08              # mov ebx, [eax+8]         ; bytes_to_write = file_length

# print length
89 D8                 # mov eax, ebx
B9 04 00 00 00        # mov ecx, 4
#:shift_loop
C1 C8 18              # ror eax, 24
9A BE 7E 00 00 08 00  # call console_put_hex
49                    # dec ecx
75 F3                 # jnz shift_loop
B0 0A                 # mov al, 0A
9A AE 7E 00 00 08 00  # call console_putc

# set starting disk location to write
31 C9                 # xor ecx, ecx
41                    # inc ecx
B6 00                 # mov dh, 0

#:sector_loop
# copy 512 bytes from file to 16 bit buffer
51                    # push ecx                 ; save disk location
BF 00 A0 00 00        # mov edi, 0x000A000
B9 00 02 00 00        # mov ecx, 0x200
F3 A4                 # rep movsb
59                    # pop ecx

# now write from 16 bit buffer
56                    # push esi                 ; save our location in the file
BE 00 A0 00 00        # mov esi, 0x000A000
B8 01 00 00 00        # mov eax, 0x0001          ; num_sectors = 1
9A 14 7F 00 00 08 00  # call write_sectors
5E                    # pop esi
81 EB 00 02 00 00     # sub ebx, 0x200           ; bytes_to_write -= 512
7F D7                 # jg sector_loop

B0 20                 # mov al, 20
9A AE 7E 00 00 08 00  # call console_putc

#:reboot
E8 47 F6 FF FF        # call enter_16bit_real, next=[87BF]
FA                    # cli
EA F0 FF 00 F0        # ljmp $F000:FFF0          ; reboot

# END

#[87C5]
               00 00 00 00 00 00 00 00 00 00 00
#[87D0]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
